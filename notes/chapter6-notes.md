# 第六章 结构  

- `sizeof` 是编译时一元运算符，可以用来计算任一对象的长度，将返回一个无符号整型值，其类型为 `size_t` ，在头文件<stddef.h>定义。使用方式：  

  &emsp;&emsp;sizeof 对象  
  
  以及    

  &emsp;&emsp;sizeof(类型名)  

- 条件编译语句 `#if` 中不能使用 `sizeof`，因为预处理器不对类型名进行分析。但是预处理器并不计算 `#define` 语句中的表达式，因此，在 `#define` 中可以使用 `sizeof`。  

- 指针之间不可以进行加法运算， 但可以进行减法运算。  

- 一个包含其自身实例的结构是非法的，但是可以包含指向自身结构的指针。如树节点的声明：  
  
  ``` C
  struct tnode{
      char *word;
      int count;
      struct tnode *left;
      strcut tnode *right;
  };
  ```  

  它将 `left` 声明为指向 `tnode` 的指针，而不是 `tnode` 实例本身，这是合法的。  

- `typedef` 类似于 `#define` 语句，但由于 `typedef` 是由编译器解释的，所以它的文本替换功能要超过预处理器的能力。例如：  
  
  `typedef int (*PFI)(char *, char *)`  

  该语句定义了类型 `PFI` 是“一个指向函数的指针，该函数有两个 `char *` 类型的参数，返回值类型为 `int` ”。  

- 使用 `typedef` 的优点：  
  1. 表达方式简洁
  2. 使程序参数化，提高程序的可移植性。例如，如果 `typedef` 声明的数据类型同机器有关，那么，当程序移植到其他机器上时，只需改变 `typedef` 类型定义就可以了。  
  3. 为程序提供更好的说明性。如将指向复杂结构的指针或指向函数的指针声明一个别名类型。  

- `union` 是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。联合提供了一种方式，以在单块存储区中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息。  

- 实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都是0，此结构空间要大到足够容纳最“宽”的成员，并且其对齐方式要适合于联合中的所有类型的成员。  

- 联合只能用其第一个成员类型的值进行初始化。  

- 位字段（bit-field）是字中相邻位的集合。例如，原来的屏蔽码集合：  

  ``` C
  #define KEYWORD 01
  #define EXTERNAL 02
  #define STATIC 04
  ```

  用位字段可以表示为：  

  ``` C
  struct{
      unsigned int is_keyword : 1;
      unsigned int is_extern  : 1;
      unsigned int is_static  : 1;
  }flags;
  ```  

  变量 `flags` 包含3个1位的字段，冒号后边的数字表示字段的宽度。每个字段的引用方式与其他结构成员相同，例如： `flags.is_keyword = 1` 。

- 字段的所有属性几乎都同具体的实现有关。字段是否能覆盖字边界由具体的实现定义。字段可以不命名，无名字段（只有一个冒号和宽度）起填充作用。特殊宽度0可以用来强制在下一个字边界上对齐。  

- 有些机器上字段的分配是从字的左端到右端进行的，有些则相反。所以尽管字段对维护内部定义的数据结构很有用，但在选择外部定义数据的情况向，必须仔细考虑哪端优先的问题。依赖于这些因素的程序是不可移植的。字段不是数组，并且没有地址，不能使用 `&` 运算符。  
