# 第二章 类型、运算符与表达式

* 库例程的名字通常以下划线`_`开头，所以变量名最好不要以下划线开头。

* 注意类型限定符 `signed` 和 `unsigned` 。 `unsigned` 类型数总是正值或者0，遵守算术模2<sup>n</sup>定律，n为该类型所占的位数。 **注意**： `unsigned` 类型用于循环时的细节问题。比如：
    ```C
    unsigned int i;
    for(i = 10; i >= 0; --i){
        // do something
    }
    ```
由于变量 `i` 是 `unsigned int` 型，所以 `i` 始终大于等于0，该循环是个死循环。

* 转义字符其实只表示一个字符。如 `\0` 表示值为0的字符。

* 常量表达式是仅仅只包含常量的表达式，在编译时求值。

* 字符串常量就是字符数组。字符串在内部表示使用一个空字符 `\0` 作为串结尾，因此，存储字符串的物理存储单元数比双引号内的字符数多一个。

* 在没有显式声明的情况下， `enum` 类型中第一个枚举名的值为0，第二个为1，以此类推（Java同）。如果指定了部分枚举名的值，那么未指定的将按照最后一个指定值向后递增。
    ```C
    // JAN值为1，FRB为2，依此类推
    enum months {JAN = 1, FRB, MAR, APR, MAY, JUN,
                JUL, AUG, SEP, OCT, NOV, DEC };
    ```
不同枚举中的名字必须互不相同。同一枚举中不同名字可以有相同值。

* 每次进入函数或程序时，显式初始化的自动变量（局部变量）豆浆杯自动初始化一次。默认情况下，外部变量和静态变量被初始化为类型0。未经显式初始化的自动变量的值为未定义值（即无效值）。

* 使用 `const` 限定的变量不能修改。

* C语言没有指定 `char` 类型的变量为无符号变量还是有符号变量。其结果取决于具体机器。不过C语言的定义保证了机器的标准打印字符集中的字符不会是负值。为了保证程序的可移植性，如要在 `char` 类型变量中存储非字符数据，最好指定 `signed` 或 `unsigned` 限定符。

* 自增、自减运算符。作为前缀运算符时，是先将变量值递增1，然后再使用；作为后缀运算符时，是先使用变量值，再将变量值递增1。

* 移位运算中，注意右移位 `>>` 时，对于有符号变量和无符号变量，存在逻辑移位（高位补0）和算术移位（高位用符号位填充）的区别。(Java中使用 `>>>` 来实现无符号右移）

* 取反运算符 `~` 。如 `x = x & ~077` 将x的最后6位置0。表达式 `x & 077` 与**机器字长无关**，它比形式为 `x & 0177700` 的表达式要好，因为后者假定x为16位的数值。

* 如果expr1和expr2是表达式，那么 

    ```C
    expr1 op= expr2
    ```
    
等价于：

    ```C 
    expr1 = (expr1) op (expr2)
    ```
    
区别在于前者expr1只计算了一次。注意第二种形式中的括号是必不可少的。例如

    ```C
    x *= y + 1
    ```
    
的含义是：

    ```C
    x = x * (y + 1)
    ```
    
而不是：

    ```C
    x = x * y + 1
    ```

* C语言没有指定同一运算符中多个操作数的计算顺序（ `&&` 、 `||` 、 `?:` 和 `,` 运算符除外）。例如：

    ```C
    x = f() + g();
    ```
    
中，f()可以在g()之前计算，也可以在之后。所以：

    ```C
    printf("%d %d\n", ++n, power(2, n));//错误
    ```
    
在不同的编译器中可能产生不同的结果，这取决于n的自增运算是在power调用之前还是之后执行。解决方法是明确区分两者顺序。

    ```C
    ++n;
    printf("%d %d\n", n, power(2, n));
    ```
